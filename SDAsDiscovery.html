<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Software Development as a Discovery Procedure
        </title>
    </head>

    <body>
        <h1>
            Software Development as a Discovery Procedure
        </h1>


        <p>
            Nobel-Prize-winning economist F.A. Hayek was one of the most
            significant social theorists of the 20th century. Some despise him
            for his "neo-liberalism," and the comfort he might have given to
            the Pinochet regime in Chile. Others love him for his support of
            free markets and his defense of a liberal social order. But love
            him or hate him, no one should doubt his significance as a thinker:
            he did important work on the theory of the business cycle, on
            monetary theory, on the theory of capital, on the informational
            role of market prices, on the nature of complex phenomena, and on
            the importance of group selection in evolution.
        </p>

        <p>
            In this essay, I wish to argue that, whatever one
            thinks of Hayek's politics, his work has important insights to
            offer those advancing Lean / Agile / DevOps ideas for IT.
            Here I will focus on his paper "Competition as a Discovery
            Procedure," and note how similar Hayek's vision for the role of
            competition in the market is to the Agile understanding of the
            importance of the "development" part of the phrase "software
            development."
        </p>

        <p>
            That essay of Hayek's was written in response to the model of
            "perfect competition" that had come to dominate economics in the
            middle of the 20th century. In that model, "competition" meant a
            state of affairs in which each market particpant already knew every
            relevant detail about the market in which they particpated, and
            thus simply "accepted" a price that, somehow, mysteriously emerged
            from the "given data" of their market. In such a situation no
            actual competion, as it is commonly understood, really occurs:
            every "competitor" already knows what product to offer, what price
            to charge, and simply passively accepts their situation as it
            stands.
        </p>

        <p>
            Similarly, the waterfall model of software development simply
            assumes that what has to be discovered, in the process of software
            <i>development</i>, is already fully known at the start of the
            process. Instead of correctly understanding development as a
            <i>process</i> through which the analysts, coders, testers,
            documenters, and users come to a mutual understanding of what the
            software should really be like, the waterfall model posits that
            certain experts can fully envision what the final product should
            be, right at the start of the process. "Software development" then
            consists of these experts drawing up a "five-year plan" detailing
            how all of the other "participants" should behave, according to the
            experts' plan. No further input is needed as far as what the
            software being "developed" should actually do. (Quote from
            Domain-Driven Design here!)
        </p>

        <p>
            Hayek, describing the dependence of economists on the perfect
            competition model, admits:
        </p>

        <p>
            "It is difficult to defend economists against the charge that for
            some 40 or 50 years they have been discussing competition on
            assumptions that, if they were true of the real world, would make
            it wholly uninteresting and useless. If anyone really knew all
            about what economic theory calls the <i>data</i>, competition would
            indeed be a very wasteful method of securing adjustment to these
            facts." (179)
        </p>

        <p>
            He goes on to write:
        </p>

        <p>
            "In sports or in examinations, no less than in the world of
            government contracts or prizes for poetry, it would clearly be
            pointless to arrange for competition, if we were certain beforehand
            who would do best... I propose to consider competition as a
            procedure for the discovery of such facts as, without resort to it,
            would not be known to anyone..." (179)
        </p>

        <p>
            This, I suggest, is quite analogous to software development: it
            would be pointless to engage in such a time-consuming, mentally
            challenging activity if we knew in advance what software "would do
            best." We engage in software development to discover "such facts
            as, without resort to it, would not be known to anyone." It is only
            when we put our interface in front of real users that we find out
            if it really is "intuitive." It is only when we confront our
            theoretical calculations with the real data that we know if we got
            them right. It is only when we put our database out to meet real
            loads that we can tell if its performance is adequate. We can only
            tell if our CDN design meets our goals when it actually has to
            deliver content. None of this means that we should not plan <i>as
            much as possible</i>, in advance, to make sure our software is up
        to snuff, just that how much is possible is quite limited. 
        </p>

        <p>
            Hayek highlights the true value of competition in the following
            passage:
        </p>

        <p>
            "[C]ompetition is valuable only because, and so far as,
            its results are unpredictable and on the whole different from those
            which anyone has, or could have, deliberately aimed at...
            We do not know the facts we hope to discover means of competition,
            we can never ascertain how effective it has been discovering those
            facts that might be discovered...
            The peculiarity of competition -- which it has in common with
            scientific method -- is that its performance cannot be tested in
            particular instances where it is significant... The advantages of
            accepted scientific procedures can never be proveed scientifically,
            but only demonstrated by the common experience that, on the whole,
            they are better adapted to delivering the goods than alternative
            approaches." (180)
        </p>

        <p>
            Bjarne Stroustrup, the creator of C++, has very similar things to
            say about programming:
        </p>

        <p>
            "When we start, we rarely know the problem well. We often think we
            do... but we don't. Only a combination of thinking about the
            problem (analysis) and experimentation (design and implementation)
            gives us the solid understanding that we need to write a good
            program... It is rare to find that we had anticipated everything
            when we analyzed the problem and made the initial design. We should
            take advantage of the feedback that writing code and testing give
            us" (178).
        </p>

        <p>
            Given the that competition is a discovery procedure, and thus we
            can't ever predict, with certainty, the results of market
            competition, Hayek considers what sort of predictions economists
            can make, if any? After all, if economics is a science, we expect
            it to say at least something about the course of events. Hayek
            concludes that:
        </p>

        <p>
            "[The theory of the market's] capacity to predict is necessarily
            limited to predicting the kind of pattern, or the abstract
            character of the order that will form itself, but does not extend
            to the prediction of particular facts." (181)
        </p>

        <p>
            Similarly, in software development, although we can't anticipate in
            advance exactly what lines of code will be needed... or development
            would be done!... we can anticipate that good software will exhibit
            certain patterns. And thus we see Hayek anticipating the "pattern
            language" approach to software development that was imported from
            the architectural works of Christopher Alexander into software
            development.
        </p>

        <p>
            Let us turn aside from contemplating the market order, upon which
            Hayek focuses most of his attention, and consider the other order
            Hayek mentions: science. Although any scientific enterprise
            involves planning, we cannot possibly plan out in advance what
            discoveries we will make in the course of some scientific research:
            if we knew <i>those</i>, we would have already discovered them, and
            our research would be done: we would just be writing up the
            results. But that is precisely what the waterfall model supposes:
            we already <i>know</i> what the software in question must do:
            development is complete, and all that remains is to turn the
            requirements into an executable program: essentially, just "writing
            up the results." This approach actually blocks the process of
            discovery, as it leaves no room for the developers or the users to
            achieve new realizations in the process of turning the blueprint
            into working code, realizations that would expose the "specs," the
            master plan, as being based upon false hypotheses.
        </p>

        <p>
            Taleb on scientific discovery.
        </p>

        <p>
            One aspect of recognizing an order as a discovery procedure is the
            implication that <i>where</i> in an organization
            the most relevant discoveries will be made is also not predictable
            in advance. Many scientific discoveries have been made because a
            lab assistant failed to follow some accepted procedure, or noticed
            something her "betters" had missed. And many successful market
            innovations arose at the level of the factory floor or the sales
            visit, and not in the executive suite.
        </p>

        <p>
            The waterfall model assumes that every insight about the proper form
            of the final software product will come from the "analysts," and
            that it is the job of lesser beings, such as programmers, to simply turn
            those insights into executable code. In this respect,
            the waterfall model has much in common with "Taylorism," the
            blueprint for mass production pioneered by Frederick Taylor around
            the turn of the last century. As Jerry Muller describes it:
        </p>

        <p>
            "Taylorism was based on trying to replace the implicit knowledge of
            the workmen with mass production methods developed, planned,
            monitored, and controlled by managers. 'Under scientific
            management,' [Taylor] wrote, 'the managers assume... the burden of
            gathering together all the traditional knowledge which in the past
            has been possessed by the workmen and then of classifying,
            tabulating, and reducing this knowledge to rules, laws, formulae...
            Thus all of the planning which under the old system was done by the
            workmen, must of necessity under the new system be done by
            management in accordance with the laws of science.' (Muller,
            pp.32-33)
        </p>

        <p>
            But Taylorism and similar top-down approaches proved inadequate in
            manufacturing, as demonstrated by the triumph of the Toyota
            Production System, just as top-down planning failed in the Soviet
            Union, and just as it does in science.
        </p>


        <p>
            Once we recognize software development is a discovery procedure,
            it should prove useful to categorize some of the features of a
            program that are most likely to be discovered in the actual process
            of development, rather than having been perfectly anticipated in
            our initial analysis of our users' requirements. What I offer here
            is only intended as an initial cut at what surely is a much more
            extensive list that could be developed. With that caveat in mind,
            in the process of actually developing software, here are some
            likely areas where our initial analysis will fall short of the
            mark:
        </p>

        <ul class="nested">
            <li>
                We will discover "corner solutions" we had not anticipated.
                Corner solutions are extreme cases that are not easy to detect
                in the analysis phase, such as a buyer who has purchased every
                single product the company sells (what do we market to her?),
                or a security the price of which has dropped to zero (were we
                dividing by that price at some point?).
            </li>
            <li>
                Some aspect of the user interface that was "obvious" to the
                designers will appear completely obscure to the actual users:
                we won't know this until we put some working software in front
                of the users.
            </li>
            <li>
                A calculation or algorithm that the users thought was adequate
                to their purposes actually is not: it may have handled a few
                common cases correctly, but once exposed to real world data,
                its shortcomings may become obvious.
            </li>
            <li>
                Some part of the system may incur a load that was not
                anticipated during the analysis phase: a particular feature may
                be much more popular than was predicted, and the capacity of
                the components assigned to handle that feature might be
                swamped.
            </li>
            <li>
                There may be regulatory/legal requirements for the software
                that the users interviewed by the analysts simply took for
                granted, the violation of which will only become apparent when
                those users are faced with a working version of the software.
            </li>
            <li>
            </li>
        </ul>

        <p>
            In conclusion, I suggest that recognizing the similarity between
            the two "discovery procedures" that Hayek identified, market
            competition and science, and software development, ought to open
            fruitful avenues for future research in the Lean / Agile / DevOps
            space. In particular, theorists and practioners of modern software
            development methods might look to the work of Hayek, and his
            leading students, such as Israel Kirzner and Nobel-Prize winning
            economist Vernon Smith, for further insight concerning the 
            dynamic nature of the software development process.
        </p>


        <h3>
            Bibliography
        </h3>

        <p>
            <i>The Tyranny of Metrics</i>,
            Jerry Z. Muller,
            Princeton University Press,
            Princeton,
            2018.
        </p>

        <p>
            <i>Programming: Principles and Practice Using C++</i>,
            Bjarne Stroustrup,
            Addison-Wesley,
            Upper Saddle River (New Jersey),
            2014.
        </p>


    </body>
</html>
