<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Software Development as a Discovery Procedure
        </title>
    </head>

    <body>
        <h1>
            Software Development as a Discovery Procedure
        </h1>


        <p>
            Nobel-Prize-winning economist F.A. Hayek was one of the most
            significant social theorists of the 20th century. Some despise him
            for his "neo-liberalism," and the comfort he might have given to
            the Pinochet regime in Chile. Others love him for his support of
            free markets and his defense of a liberal social order. But love
            him or hate him, no one should doubt his significance as a thinker:
            he did important work on the theory of the business cycle, on
            monetary theory, on the theory of capital, on the informational
            role of market prices, on the nature of complex phenomena, and on
            the importance of group selection in evolution.
        </p>

        <p>
            In this essay, I wish to argue that, whatever one
            thinks of Hayek's politics, his work has important insights to
            offer those advancing Lean / Agile / DevOps ideas for IT.
            Here I will focus on his paper "Competition as a Discovery
            Procedure," and note how similar Hayek's vision for the role of
            competition in the market is to the Agile understanding of the
            importance of the "development" part of the phrase "software
            development."
        </p>

        <p>
            That essay of Hayek's was written in response to the model of
            "perfect competition" that had come to dominate economics in the
            middle of the 20th century. In that model, "competition" meant a
            state of affairs in which each market particpant already knew every
            relevant detail about the market in which they particpated, and
            thus simply "accepted" a price that, somehow, mysteriously emerged
            from the "given data" of their market. In such a situation no
            actual competion, as it is commonly understood, really occurs:
            every "competitor" already knows what product to offer, what price
            to charge, and simply passively accepts their situation as it
            stands.
        </p>

        <p>
            Similarly, the waterfall model of software development simply
            assumes that what has to be discovered, in the process of software
            <i>development</i>, is already fully known at the start of the
            process. Instead of correctly understanding development as a
            <i>process</i> through which the analysts, coders, testers,
            documenters, and users come to a mutual understanding of what the
            software should really be like, the waterfall model posits that
            certain experts can fully envision what the final product should
            be, right at the start of the process. "Software development" then
            consists of these experts drawing up a "five-year plan" detailing
            how all of the other "participants" should behave, according to the
            experts' plan. No further input is needed as far as what the
            software being "developed" should actually do. (Quote from
            Domain-Driven Design here!)
        </p>

        <p>
            Hayek, describing the dependence of economists on the perfect
            competition model, admits:
        </p>

        <p>
            "It is difficult to defend economists against the charge that for
            some 40 or 50 years they have been discussing competition on
            assumptions that, if they were true of the real world, would make
            it wholly uninteresting and useless. If anyone really knew all
            about what economic theory calls the <i>data</i>, competition would
            indeed be a very wasteful method of securing adjustment to these
            facts." (179)
        </p>

        <p>
            He goes on to write:
        </p>

        <p>
            "In sports or in examinations, no less than in the world of
            government contracts or prizes for poetry, it would clearly be
            pointless to arrange for competition, if we were certain beforehand
            who would do best... I propose to consider competition as a
            procedure for the discovery of such facts as, without resort to it,
            would not be known to anyone..." (179)
        </p>

        <p>
            This, I suggest, is quite analogous to software development: it
            would be pointless to engage in such a time-consuming, mentally
            challenging activity if we knew in advance what software "would do
            best." We engage in software development to discover "such facts
            as, without resort to it, would not be known to anyone." It is only
            when we put our interface in front of real users that we find out
            if it really is "intuitive." It is only when we confront our
            theoretical calculations with the real data that we know if we got
            them right. It is only when we put our database out to meet real
            loads that we can tell if its performance is adequate. We can only
            tell if our CDN design meets our goals when it actually has to
            deliver content. None of this means that we should not plan <i>as
            much as possible</i>, in advance, to make sure our software is up
        to snuff, just that how much is possible is quite limited. 
        </p>

        <p>
            Hayek highlights the true value of competition in the following
            passage:
        </p>

        <p>
            "[C]ompetition is valuable only because, and so far as,
            its results are unpredictable and on the whole different from those
            which anyone has, or could have, deliberately aimed at...
            We do not know the facts we hope to discover means of competition,
            we can never ascertain how effective it has been discovering those
            facts that might be discovered...
            The peculiarity of competition -- which it has in common with
            scientific method -- is that its performance cannot be tested in
            particular instances where it is significant... The advantages of
            accepted scientific procedures can never be proveed scientifically,
            but only demonstrated by the common experience that, on the whole,
            they are better adapted to delivering the goods than alternative
            approaches." (180)
        </p>

        <p>
            Bjarne Stroustrup, the creator of C++, has very similar things to
            say about programming:
        </p>

        <p>
            "When we start, we rarely know the problem well. We often think we
            do... but we don't. Only a combination of thinking about the
            problem (analysis) and experimentation (design and implementation)
            gives us the solid understanding that we need to write a good
            program... It is rare to find that we had anticipated everything
            when we analyzed the problem and made the initial design. We should
            take advantage of the feedback that writing code and testing give
            us" (178).
        </p>


        <p>
            "[The theory of the market's] capacity to predict is necessarily
            limited to predicting the kind of pattern, or the abstract
            character of the order that will form itself, but does not extend
            to the prediction of particular facts." (181)
        </p>

        <p>
            Here, we see Hayek anticipating the "pattern language" approach to
            software development that was imported from the architectural works
            of Chrsitopher Alexander into software development.
        </p>

        <p>
            Let us turn aside from contemplating the market order, upon which
            Hayek focuses most of his attention, and consider the other order
            Hayek mentions: science. Although any scientific enterprise
            involves planning, we cannot possibly plan out in advance what
            discoveries we will make in the course of some scientific research:
            if we knew <i>those</i>, we would have already discovered them, and
            our research would be done: we would just be writing up the
            results. But that is precisely what the waterfall model supposes:
            we already <i>know</i> what the software in question must do:
            development is complete, and all that remains is to turn the
            requirements into an executable program: essentially, just "writing
            up the results." This approach actually blocks the process of
            discovery, as it leaves no room for the developers or the users to
            achieve new realizations in the process of turning the blueprint
            into working code, realizations that would expose the "specs," the
            master plan, as being based upon false hypotheses.
        </p>

        <p>
            Taleb on scientific discovery.
        </p>

        <p>
            The waterfall model has much in common with "Taylorism," the
            blueprint for mass production pioneered by Frederick Taylor around
            the turn of the last century. As Jerry Muller describes it:
            </p>

        <p>
            "Taylorism was based on trying to replace the implicit knowledge of
            the workmen with mass production methods developed, planned,
            monitored, and controlled by managers. 'Under scientific
            management,' [Taylor] wrote, 'the managers assume... the burden of
            gathering together all the traditional knowledge which in the past
            has been possessed by the workmen and then of classifying,
            tabulating, and reducing this knowledge to rules, laws, formulae...
            Thus all of the planning which under the old system was done by the
            workmen, must of necessity under the new system be done by
            management in accordance with the laws of science.' (Muller,
            pp.32-33)
        </p>


        <p>
            Once we recognize software development is a discovery procedure,
            with strong simlarities to the ways in which market competition and
            scientific practice are also discovery procedures, it should prove
            useful to categorize some of the features of a program that are
            most likely to be discovered in the actual process of development,
            rather than having been perfectly anticipated in our initial
            analysis of our users' requirements. What I offer here is only
            intended as an initial cut at what surely is a much more extensive
            list that could be developed. With that caveat in mind, in the
            process of actually developing software, here are some likely areas
            where our initial analysis will fall short of the mark:
        </p>

        <ul>
            <li>
                We will discover "corner solutions" we had not anticipated.
            </li>
            <li>
            </li>
            <li>
            </li>
            <li>
            </li>
        </ul>


        <h3>
            Bibliography
        </h3>

        <p>
            <i>The Tyranny of Metrics</i>,
            Jerry Z. Muller,
            Princeton University Press,
            Princeton,
            2018.
        </p>

        <p>
            <i>Programming: Principles and Practice Using C++</i>,
            Bjarne Stroustrup,
            Addison-Wesley,
            Upper Saddle River (New Jersey),
            2014.
        </p>


    </body>
</html>
